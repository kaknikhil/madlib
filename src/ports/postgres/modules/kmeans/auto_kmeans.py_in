# coding=utf-8
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

"""
@file auto_kmeans.py_in

@brief 

"""


import numpy as np
import math
import plpy

def validate():

    pass

def set_defaults(k, k_selection_algorithm):

    k = k if k is not None else range(5,15)
    
    k_selection_algorithm = (k_selection_algorithm 
        if k_selection_algorithm is not None else'elbow')

    return k, k_selection_algorithm


def auto_kmeans(schema_madlib, rel_source, expr_point, output_table, k, 
    fn_dist, agg_centroid, max_num_iterations, min_frac_reassigned, 
    k_selection_algorithm, seeding, seeding_sample_ratio=None, **kwargs):

    validate()

    k, k_selection_algorithm = set_defaults(k, k_selection_algorithm)

    plpy.execute(""" 
        CREATE TABLE {output_table} (       
            k_val INTEGER, 
            centroids   DOUBLE PRECISION[][],
            cluster_variance    DOUBLE PRECISION[],
            objective_fn    DOUBLE PRECISION,
            frac_reassigned DOUBLE PRECISION,
            num_iterations  INTEGER)
        """.format(**locals()))

    for current_k in k:

        plpy.info("Executing k: {}".format(current_k))
        if seeding is 'random':
            plpy.execute("""
                INSERT INTO {output_table}
                SELECT {current_k} as k_val, * 
                FROM madlib.kmeans_random('{rel_source}', 
                                     '{expr_point}', 
                                     {current_k},
                                     '{fn_dist}',
                                     '{agg_centroid}', 
                                     {max_num_iterations}, 
                                     {min_frac_reassigned});
                """.format(**locals()))
        else:
            plpy.execute("""
                INSERT INTO {output_table}
                SELECT {current_k} as k_val, * 
                FROM madlib.kmeanspp('{rel_source}', 
                                     '{expr_point}', 
                                     {current_k},
                                     '{fn_dist}',
                                     '{agg_centroid}', 
                                     {max_num_iterations}, 
                                     {min_frac_reassigned}, 
                                     {seeding_sample_ratio});
                """.format(**locals()))


    intertia_list = plpy.execute("""
             SELECT k_val, objective_fn from {output_table}
             """.format(**locals()))

    inertia_dict = {}
    for i in range(len(intertia_list)):
        inertia_dict[intertia_list[i]['k_val']] = intertia_list[i]['objective_fn']
        if intertia_list[i]['objective_fn'] == 0:
            break

    est_k = inertia_dict.keys()
    est_inertia = inertia_dict.values()

    first_order=np.gradient(est_inertia)
    second_order=np.gradient(first_order)
    index_with_elbow=np.argmax(second_order)

    optimal_k = est_k[index_with_elbow]
    plpy.info("elbow: {} {} {}".format(optimal_k, est_inertia, second_order))

    return
    

def auto_kmeans_random(schema_madlib, rel_source, expr_point, output_table, k, 
    fn_dist, agg_centroid, max_num_iterations, min_frac_reassigned, 
    seeding_sample_ratio, k_selection_algorithm, **kwargs):

    auto_kmeans(schema_madlib, rel_source, expr_point, output_table, k, 
    fn_dist, agg_centroid, max_num_iterations, min_frac_reassigned, 
    k_selection_algorithm, 'pp', seeding_sample_ratio)
    
    return

def auto_kmeanspp(schema_madlib, rel_source, expr_point, output_table, k, 
    fn_dist, agg_centroid, max_num_iterations, min_frac_reassigned, 
    k_selection_algorithm, **kwargs):

    auto_kmeans(schema_madlib, rel_source, expr_point, output_table, k, 
    fn_dist, agg_centroid, max_num_iterations, min_frac_reassigned, 
    k_selection_algorithm, 'random')
    
    return